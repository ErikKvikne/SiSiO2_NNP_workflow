#!/usr/bin/env python3

import os
import sys
import glob
import shutil
import re

def check_md_success(err_file):
    """Check if the MD simulation ran successfully by inspecting the .err file."""
    with open(err_file, 'r') as f:
        content = f.read()
    if 'error' in content.lower() or 'srun: error' in content.lower():
        return False
    return True

def copy_snapshot(source_path, dest_dir, new_filename):
    """Copy the snapshot.lammpstrj file to the destination directory."""
    if not os.path.exists(dest_dir):
        os.makedirs(dest_dir)
    dest_path = os.path.join(dest_dir, new_filename)
    shutil.copy2(source_path, dest_path)
    return dest_path

def parse_lammpstrj(file_path, timesteps):
    """Parse the LAMMPS trajectory file and extract specified timesteps."""
    snapshots = {}
    with open(file_path, 'r') as f:
        lines = f.readlines()
    i = 0
    while i < len(lines):
        if 'ITEM: TIMESTEP' in lines[i]:
            timestep = int(lines[i+1].strip())
            i += 2
            if timestep in timesteps:
                # Extract snapshot
                snapshot_lines = []
                snapshot_lines.append(''.join(lines[i-2:i]))  # TIMESTEP and number
                while i < len(lines) and 'ITEM: TIMESTEP' not in lines[i]:
                    snapshot_lines.append(lines[i])
                    i += 1
                snapshots[timestep] = snapshot_lines
            else:
                # Skip to next timestep
                while i < len(lines) and 'ITEM: TIMESTEP' not in lines[i]:
                    i += 1
        else:
            i += 1
    return snapshots

def write_cif(snapshot_lines, output_file):
    """Write the extracted snapshot to a CIF file."""
    # Extract box dimensions and atom data
    box_bounds = []
    atom_data = []
    parsing_atoms = False
    for line in snapshot_lines:
        if 'ITEM: BOX BOUNDS' in line:
            idx = snapshot_lines.index(line)
            for j in range(1, 4):
                bounds = snapshot_lines[idx + j].strip().split()
                box_bounds.append([float(bounds[0]), float(bounds[1])])
        elif 'ITEM: ATOMS' in line:
            parsing_atoms = True
            headers = line.strip().split()[2:]
        elif parsing_atoms:
            atom_info = line.strip().split()
            atom_dict = dict(zip(headers, atom_info))
            atom_data.append(atom_dict)

    # Compute cell dimensions
    a = box_bounds[0][1] - box_bounds[0][0]
    b = box_bounds[1][1] - box_bounds[1][0]
    c = box_bounds[2][1] - box_bounds[2][0]

    # Write to CIF file
    with open(output_file, 'w') as f:
        f.write('data_generated_cif\n')
        f.write('_audit_creation_method Generated by automate_cp2k.py\n')
        f.write(f'_cell_length_a    {a}\n')
        f.write(f'_cell_length_b    {b}\n')
        f.write(f'_cell_length_c    {c}\n')
        f.write('_cell_angle_alpha    90.0\n')
        f.write('_cell_angle_beta     90.0\n')
        f.write('_cell_angle_gamma    90.0\n\n')
        f.write('loop_\n')
        f.write('_atom_site_label\n')
        f.write('_atom_site_type_symbol\n')
        f.write('_atom_site_fract_x\n')
        f.write('_atom_site_fract_y\n')
        f.write('_atom_site_fract_z\n')

        # 2 is Si and 1 is oxygen
        type_mapping = {'2': 'Si', '1': 'O'}

        for atom in atom_data:
            # Convert positions to fractional coordinates
            x = float(atom['x'])
            y = float(atom['y'])
            z = float(atom['z'])
            x_frac = (x - box_bounds[0][0]) / a
            y_frac = (y - box_bounds[1][0]) / b
            z_frac = (z - box_bounds[2][0]) / c
            atom_label = atom.get('id', 'X')
            atom_type = type_mapping.get(atom['type'], 'X')
            f.write(f"{atom_label} {atom_type} {x_frac:.6f} {y_frac:.6f} {z_frac:.6f}\n")

def generate_cp2k_input(template_file, project_name, cell_file_name, output_file):
    """Generate the CP2K input file from the template."""
    with open(template_file, 'r') as f:
        template = f.read()
    template = template.replace('<PROJECT>', project_name)
    template = template.replace('<CELL_FILE_NAME>', cell_file_name)
    with open(output_file, 'w') as f:
        f.write(template)

def generate_submit_script(project_name, cp2k_input_file, submit_script_file):
    """Generate the SLURM submission script."""
    submit_script = f"""#!/bin/bash
#SBATCH --job-name={project_name}  # Job name
#SBATCH --time=01:00:00        # Max. duration of the job
#SBATCH --mem-per-cpu=1G       # Memory to reserve per core
#SBATCH --partition=large      # Job queue (partition)
#SBATCH --nodes=4        # Number of nodes
#SBATCH --ntasks=4       # Number of tasks (MPI tasks)
#SBATCH --cpus-per-task=8  # Number of CPU cores per task

#SBATCH --output=%j_stdout.txt
#SBATCH --error=%j_stderr.txt

#SBATCH --account=jeakola      # Billing project

module purge
module load gcc/13.2.0
module load openmpi/5.0.5
module load cp2k/2024.2

export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK

# Run CP2K using the generated input file
srun cp2k.psmp -i {cp2k_input_file} > {project_name}.out 2>&1
"""
    with open(submit_script_file, 'w') as f:
        f.write(submit_script)
    os.chmod(submit_script_file, 0o755)

def main():
    import argparse

    parser = argparse.ArgumentParser(description='Automate CP2K input and job submission script generation.')
    parser.add_argument('--md_folder', required=True, help='Path to the folder containing MD simulations.')
    parser.add_argument('--destination_folder', required=True, help='Destination folder for snapshots.')
    parser.add_argument('--timesteps', nargs='+', type=int, help='List of timesteps to extract.')
    parser.add_argument('--interval', type=int, help='Interval at which to extract timesteps.')
    #parser.add_argument('--cp2k_template', required=True, help='Path to CP2K input template.')
    args = parser.parse_args()

    md_folder = args.md_folder
    destination_folder = args.destination_folder
    cp2k_template = "/users/ekvikne/automate/cp2k_input_template.inp"

    if args.timesteps:
        timesteps = args.timesteps
    elif args.interval:
        timesteps = []
        # Adjust the maximum timestep based on your data
        max_timestep = 10000  # Placeholder value
        timesteps = list(range(0, max_timestep + 1, args.interval))
    else:
        print("Please specify either --timesteps or --interval.")
        sys.exit(1)

    # Collect all MD simulation folders
    md_sim_folders = [os.path.join(md_folder, d) for d in os.listdir(md_folder)
                      if os.path.isdir(os.path.join(md_folder, d))]

    master_launch_script = os.path.join(destination_folder, 'launch_all_jobs.sh')
    with open(master_launch_script, 'w') as master_script:
        master_script.write('#!/bin/bash\n\n')

        for sim_folder in md_sim_folders:
            sim_name = os.path.basename(sim_folder)
            # Check if MD run was successful
            err_files = sorted(glob.glob(os.path.join(sim_folder, 'my_job_*.err')), key=os.path.getmtime)
            if not err_files:
                print(f"No .err file found in {sim_folder}. Skipping.")
                continue
            err_file = err_files[-1]  # Use the most recent .err file
            if not check_md_success(err_file):
                print(f"MD run in {sim_folder} did not finish successfully. Skipping.")
                continue

            # Copy snapshot.lammpstrj to destination
            snapshot_src = os.path.join(sim_folder, 'snapshot.lammpstrj')
            if not os.path.exists(snapshot_src):
                print(f"No snapshot.lammpstrj found in {sim_folder}. Skipping.")
                continue

            dest_sim_folder = os.path.join(destination_folder, sim_name)
            snapshot_dest = os.path.join(dest_sim_folder, f'{sim_name}.lammpstrj')
            copy_snapshot(snapshot_src, dest_sim_folder, f'{sim_name}.lammpstrj')

            # Parse the snapshot file and extract specified timesteps
            snapshots = parse_lammpstrj(snapshot_dest, timesteps)

            for timestep, snapshot_lines in snapshots.items():
                timestep_folder = os.path.join(dest_sim_folder, f'timestep_{timestep}')
                if not os.path.exists(timestep_folder):
                    os.makedirs(timestep_folder)

                # Write the CIF file
                cif_filename = f'{sim_name}_timestep_{timestep}.cif'
                cif_filepath = os.path.join(timestep_folder, cif_filename)
                write_cif(snapshot_lines, cif_filepath)

                # Update project_name to include timestep
                project_name_with_timestep = f"{sim_name}_timestep_{timestep}"

                # Generate CP2K input file
                cp2k_input_file = os.path.join(timestep_folder, 'cp2k_input.inp')
                generate_cp2k_input(cp2k_template, project_name_with_timestep, cif_filename, cp2k_input_file)

                # Generate submission script
                submit_script_file = os.path.join(timestep_folder, 'submit.sh')
                generate_submit_script(project_name_with_timestep, 'cp2k_input.inp', submit_script_file)

                # Add job submission to master script
                master_script.write(f'cd {timestep_folder}\n')
                master_script.write(f'sbatch submit.sh\n')
                master_script.write(f'cd -\n\n')

    os.chmod(master_launch_script, 0o755)
    print(f"Master launch script created at {master_launch_script}")

if __name__ == '__main__':
    main()
